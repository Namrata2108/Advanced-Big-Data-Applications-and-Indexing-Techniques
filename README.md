## INFO 7255 - Project to demonstrate Indexing of Structured JSON objects

### Features
- Authentication using Bearer Token generated by JWT
- Validate request JSON object with JSON Schema
- Cache Server Response and validate cache using ETag
- Support POST, PUT, PATCH, GET and DELETE Http Methods for the REST API
- Store JSON Objects in Redis key-value store for data persistence
- Index the JSON Objects in Elastic Server for Search capabilities
- Queueing indexing requests to Elastic Server using RabbitMQ


### Tech Stack
- Spring Boot (Java)
- Redis 
- Elastic Search
- RabbitMQ

### Data Flow
1. Obtain a token by utilizing the /token endpoint.
2. Subsequently, authenticate additional API requests using the acquired Bearer Token.
3. Employ the POST HTTP method to construct a JSON Object.
4. Verify incoming JSON Objects by applying the corresponding JSON Schema validation.
5. Deconstruct complex JSON Objects and efficiently store them within the Redis key-value store.
6. Place objects within the RabbitMQ queue to initiate the indexing process.
7. Extract objects from the RabbitMQ queue, facilitating their indexing within ElasticServer.
8. Implement search queries via the Kibana Console for the purpose of retrieving the indexed data.

### Default ports:
1. Elasticsearch - http://localhost:9200
2. Kibana - http://localhost:5601
3. RabbitMQ - http://localhost:15762
4. Application - http://localhost:8080

### Build and Run 
1. Start the services - Elasticsearch, Kibana, and RabbitMQ
2. Run as Spring Boot Application in any IDE

Initiate the server to begin operations. Utilize the REST API endpoints to generate data and subsequently execute queries on the indexed data via the Kibana Console.


### API Endpoints

- GET `/token` - This generates an RSA-signed JWT token used to authenticate requests
- POST `/validate` - This validates the token
- POST `/plan` - Creates a new plan provided in the request body
- PUT `/{objectType}/{objectId}` - Updates an existing plan provided by the objectId
    - A valid Etag for the object should also be provided in the `If-Match` HTTP Request Header
- PATCH `/{objectType}/{objectId}` - Patches an existing plan provided by the objectId
    - A valid Etag for the object should also be provided in the `If-Match` HTTP Request Header
- GET `/{objectType}/{objectId}` - Fetches an existing plan provided by the objectId
    - An Etag for the object can be provided in the `If-None-Match` HTTP Request Header
    - If the request is successful, a valid Etag for the object is returned in the `ETag` HTTP Response Header
- DELETE `/{objectType}/{objectId}` - Deletes an existing plan provided by the objectId
    - A valid Etag for the object should also be provided in the `If-Match` HTTP Request Header
